---
title: 浮点数表示与计算误差
date: 2020-04-06 14:00:27
---

### 为什么在 JavaScript 中计算浮点数可能存在误差？

<!-- more -->

```typescript
console.log(0.1 + 0.2); // 0.30000000000000004
```

### 浮点数在计算机中的表示

计算机使用二进制表示、存储和处理数据。为什么采用二进制，而不是人们更熟悉的十进制：因为使用物理电路模拟二进制数据状态更加容易，电路闭合为 1，电路断开为 0，通过电路闭合断开的物理过程来模拟数据的计算过程。

JavaScript 中的所有数字类型的表示都遵循一个叫 IEEE 754 的国际标准，使用双精度 64bit（没有采用单精度 32bit）组成

- 单精度 32bit
  ![0](https://i.loli.net/2020/04/06/WYmgiF2QcI8K3HB.jpg)

- 双精度 64bit
  ![1](https://i.loli.net/2020/04/06/r8ojvNs5cXf2BIQ.jpg)

计算公式

![2](https://i.loli.net/2020/04/06/Rfp9T5V3hvwg6MD.png)

- 符号位 S：第 1 位是正负数符号位（sign），0 代表正数，1 代表负数
- 指数位 E：中间的 11 位存储指数（exponent），用来表示次方数
- 尾数位 M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零

IEEE 754 对有效数字 M 和指数 E，还有一些特别规定。

前面说过，1≤M<2，也就是说，M 可以写成 1.xxxxxx 的形式，其中 xxxxxx 表示小数部分。IEEE 754 规定，在计算机内部保存 M 时，默认这个数的第一位总是 1，因此可以被舍去，只保存后面的 xxxxxx 部分。比如保存 1.01 的时候，只保存 01，等到读取的时候，再把第一位的 1 加上去。这样做的目的，是节省 1 位有效数字。以 64 位浮点数为例，留给 M 只有 52 位，将第一位的 1 舍去以后，等于可以保存 53 位有效数字。

至于指数 E，情况就比较复杂。

首先，E 为一个无符号整数（unsigned int）。这意味着，如果 E 为 8 位，它的取值范围为 0\~255；如果 E 为 11 位，它的取值范围为 0\~2047。但是，我们知道，科学计数法中的 E 是可以出现负数的，所以 IEEE 754 规定，E 的真实值必须再减去一个中间数，对于 8 位的 E，这个中间数是 127；对于 11 位的 E，这个中间数是 1023。

所以 JavaScript 中数字表示的最终公式变成：

![3](https://i.loli.net/2020/04/06/gRyDY4B8lLo7vF3.png)

比如，2^10 的 E 是 10，所以保存成 32 位浮点数时，必须保存成 10+127=137，即 10001001。

然后，指数 E 还可以再分成三种情况：

- E 不全为 0 或不全为 1。这时，浮点数就采用上面的规则表示，即指数 E 的计算值减去 127（或 1023），得到真实值，再将有效数字 M 前加上第一位的 1。
- E 全为 0。这时，浮点数的指数 E 等于 1-127（或者 1-1023），有效数字 M 不再加上第一位的 1，而是还原为 0.xxxxxx 的小数。这样做是为了表示 ±0，以及接近于 0 的很小的数字。
- E 全为 1。这时，如果有效数字 M 全为 0，表示 ± 无穷大（正负取决于符号位 s）；如果有效数字 M 不全为 0，表示这个数不是一个数（NaN）。

回到 `0.1+0.2 !== 0.3`，把各个数字的单独表示

> 访问 <http://www.binaryconvert.com/result_double.html> 在线转换

| 数字 | 符号位 | 指数位      | 有效数位                                             | 是否循环 |
| ---- | ------ | ----------- | ---------------------------------------------------- | -------- |
| 0.1  | 0      | 01111111011 | 1001100110011001100110011001100110011001100110011010 | 1100     |
| 0.2  | 0      | 01111111100 | 1001100110011001100110011001100110011001100110011010 | 1100     |

所以 0.1 和 0.2 表示成 IEEE 754 后有效数位都以 1001 无限循环，加起来结果

```text
  0.0001100110011001100110011001100110011001100110011001101
  0.0011001100110011001100110011001100110011001100110011010
+ ---------------------------------------------------------
  0.0100110011001100110011001100110011001100110011001100111 => 0.30000000000000004
```

### 为什么 x=0.1 能得到 0.1？隐式精度转换

因为 mantissa 固定长度是 52 位，再加上省略的一位，最多可以表示的数是 2^53=9007199254740992，对应科学计数尾数是 9.007199254740992，这也是 JS 最多能表示的精度。它的长度是 16，所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理。于是就有：

```typescript
// 返回 0.1000000000000000，去掉末尾的零后正好为 0.1
(0.100000000000000005551).toPrecision(16); // 0.1

// 但你看到的 `0.1` 实际上并不是 `0.1`。不信你可用更高的精度试试：
(0.1).toPrecision(21); // 0.100000000000000005551;
```

### 最大可表示数字

```typescript
Math.pow(2, 1023); // 8.98846567431158e+307
Math.pow(2, 1024); // Infinity
```

> 可以使用第三方库解决大数计算问题 <https://github.com/MikeMcl/bignumber.js/>

### 十进制转换二进制的方法

以 0.1 举例

| 计算           | 取整 | 取余 |
| -------------- | ---- | ---- |
| 0.1 \* 2 = 0.2 | 0    | 0.2  |
| 0.2 \* 2 = 0.4 | 0    | 0.4  |
| 0.4 \* 2 = 0.8 | 0    | 0.8  |
| 0.8 \* 2 = 1.6 | 1    | 0.6  |
| 0.6 \* 2 = 1.2 | 1    | 0.2  |
| 0.2 \* 2 = 0.4 | 0    | 0.4  |
| 0.4 \* 2 = 0.8 | 0    | 0.8  |
| ...            | ...  | ...  |

`0.1 => 0.00011001100...`

### 易混淆 API

| API         | 功能                                                |
| ----------- | --------------------------------------------------- |
| toPrecision | 是处理精度，精度是从左至右第一个不为 0 的数开始数起 |
| toFixed     | 是小数点后指定位数取整，从小数点开始数起            |

两者都能对多余数字做凑整处理，也有些人用 toFixed 来做四舍五入，但一定要知道它是有 Bug 的。

例如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01。

原因：1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去！

> 项目地址：<https://github.com/defpis/calculate-float-number-in-js>
